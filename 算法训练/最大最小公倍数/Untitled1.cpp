/*题意：求1-N里面，任意三个数的最小公倍数的最大值.


思路：若n 和 n-1和n-2 三个数 两两互质的话，那么结果就是这三个数的积。

根据数论知识：任意大于1的两个相邻的自然数都是互质的.

我们可以知道，当n是奇数时，n 和n-2都是奇数，n-1是偶数,那么他们三个的公约数肯定不是2,
而因为这三个数是连续的，所以大于2的数都不可能成为他们或其中任意两个数的公约数了.
结果就是他们三个的乘积.

而当n为偶数时，n*(n-1)*(n-2)肯定不行了，因为n和n-2都是偶数，那么只能将n-2改成n-3，
即n*(n-1)*(n-3),如果这三个数两两互质那么肯定就是结果了.

但是因为n和n-3相差3,所以当其中一个数能被3整除时，另一个肯定也可以.而当其中一个不可以时，
另一个肯定也不可以.而因为n为偶数,n-3为奇数，所以2不可能成为他俩的公因子。对于大于3的数，
肯定就都不可能成为这三个数或者其中任意两个数的公约数了.因此只需再对3进行判断：

如果n能整除3，那么，n*(n-1)*(n-3)就肯定不行了，因为n和n-3有了公约数3，结果肯定小了，
那么就只能继续判下一个即n*(n-1)*(n-4)而这样n-4又是偶数，
不行继续下一个n*(n-1)*(n-5) = n^3 -6*n^2 + 5*n 
而如果这个可以 那个其值肯定要小于(n-1)*(n-2)*(n-3) = n^3 -6*n^2+11n-6(对于n>1来说都成立),
而(n-1)*(n-2)*(n-3)由上一个奇数结论可知是一个符合要求的，因此到n-5就不用判断了。
直接选答案为(n-1)*(n-2)*(n-3)；

而n不能整除3，那么结果就是n*(n-1)*(n-3)，
因为n和n-3都不能整除3,此时n-1能不能整除3都无关紧要了.而对于其它数 都是不可能的.上面已证.


代码上：

[cpp] view plaincopyprint?在CODE上查看代码片派生到我的代码片*/
#include <iostream>  
#include <cstdio>  
using namespace std;  
const int MAX_ = 100;  
  
  
int gcd(int a,int b){  
        int r = a%b;  
        while(r){  
            a = b;  
            b = r;  
            r = a%b;  
        }  
        return b;  
}  
  
long long lcm(int a, int b){  
    return a*b/gcd(a,b);  
}  
  
int main(){  
    long long ans, n;  
  
    while(cin >> n){  
            if(n<=2){  
                ans = n;  
            }  
            else if(n%2){  
                ans = n*(n-1)*(n-2);  
            }  
            else {  
                if(n%3){  
                    ans = n*(n-1)*(n-3);  
                }  
                else ans = (n-3)*(n-1)*(n-2);  
            }  
            cout<<ans<<endl;  
    }  
    return 0;  
}  
